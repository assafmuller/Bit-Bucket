<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Bit Bucket: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bit Bucket
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Introduction:</b></p>
<p><a class="el" href="class_bit.html">Bit</a> Bucket is a C++ heterogeneous container / hash map, where each cell holds one of the following intrinsic types: bool, char, int, float and std::string. The type of the variant can change during runtime.</p>
<p>Here's a few examples to explain the idea:</p>
<p>Getting data into the bucket: </p>
<pre class="fragment">BitBucket bucket;
bucket["int"] = 42; // First an int
bucket["int"] = "rock!"; // Then a string
bucket["f"] = 3.14f;
bucket["string"] = "Soundgarden";
std::cout &lt;&lt; bucket["string"] &lt;&lt; " " &lt;&lt; bucket["int"];
</pre><p>Output: "Soundgarden rock!". </p>
<pre class="fragment">bucket["int"] = 42;
bucket["float"] = 3.14f;
int x = bucket["int"]; // x is now equal to 42
x = bucket["float"]; // The float value has been truncated to 3
std::string s = bucket["int"]; // s is now equal to "42". Conversion works from strings to numbers and vice versa.

bucket["s"] = "Not a number";
int y = bucket["s"]; // y is equal to 0 and the stack trace will be printed
bool flag = bucket["nonExistant"]; // bool will be equal to false, and the stack trace will be printed
</pre><p><b>The classes:</b></p>
<p><em><a class="el" href="class_bit_bucket.html">BitBucket</a></em> is a class that inherits from std::unordered_map, and adds the following functionality:</p>
<ol type="1">
<li>Construction from a text file. The file must be of the following format: &lt;type&gt; &lt;name&gt; </li>
</ol>
<p>&lt;type&gt; &lt;name&gt; </p>
<p>... Note: type must be one of the following types: bool, char, int, float, string or auto, where stating auto will automatically deduce the type of the variable according to its value, much like C++11's auto keyword.</p>
<ol type="1">
<li>Output to a text file via <a class="el" href="class_bit_bucket.html#a5963706493f5e4a0932dfaeb15d0c6e5">BitBucket::serialize</a></li>
</ol>
<ol type="1">
<li>Console output via <a class="el" href="class_bit_bucket.html#a06bc2a7f6d4c26793e020654bb280374">BitBucket::print</a></li>
</ol>
<ol type="1">
<li>Printing only the blank cells via <a class="el" href="class_bit_bucket.html#af2f9a4b56724f78a97dbeb07ad97b6f5">BitBucket::printBlank</a>. More on this in the error handling section.</li>
</ol>
<p><em><a class="el" href="class_bit.html">Bit</a></em> is what the <a class="el" href="class_bit_bucket.html">BitBucket</a> holds. This class is essentially a wrapper for boost::variant, with the following added functionality:</p>
<ol type="1">
<li>Constructor that accepts string type, string value (Reading from a file, for example).</li>
</ol>
<ol type="1">
<li>Output streaming.</li>
</ol>
<ol type="1">
<li>Conversion from the <a class="el" href="class_bit.html">Bit</a> class to bool, char, int, float or string. Conversions are done according to expected C functionality. For example: A <a class="el" href="class_bit.html">Bit</a> holding 3.14f will convert to an int implicitly by truncation. In addition, strings will also attempted to be converted to the other types.</li>
</ol>
<p><b>Error handling:</b></p>
<p>Two types of errors may commonly occur when working with a <a class="el" href="class_bit.html">Bit</a> Bucket:</p>
<ol type="1">
<li>Access to an invalid cell. For example: <pre class="fragment"> int x = bucket["nonExistant"];
</pre></li>
</ol>
<ol type="1">
<li>Accessing the variant with a wrong type / An incorrect type cast: <pre class="fragment"> bucket["string"] = "Jerusalem";
 int x = bucket["string"]; // Can only convert strings representing numbers, not words
</pre></li>
</ol>
<p>What do we do in these cases?</p>
<p>In the first case, the cell "nonExistant" will be created and its type will be boost::blank, which is a completely empty struct. x will equal 0. There is no exception or crash. Similarly, in the second case x will be equal to 0 and the stack trace will be printed. So how do we catch such errors?</p>
<ol type="1">
<li>The stack trace will be printed, so you'll know exactly which line of code caused either kind of error, the moment it occurs. The stack trace is printed via <a class="el" href="class_stack_walker.html">StackWalker</a> on Windows, and backtrace() on Linux. The stack tracing is conditionally compiled into the library, so if you got this library already compiled keep that in mind.</li>
</ol>
<ol type="1">
<li>You may use <a class="el" href="class_bit_bucket.html#af2f9a4b56724f78a97dbeb07ad97b6f5">BitBucket::printBlank()</a> to see which cells are blank.</li>
</ol>
<ol type="1">
<li>You may use BitBucket::isSet(string key) to see if a cell exists before accessing it.</li>
</ol>
<p><b>Requirements:</b></p>
<p><a class="el" href="class_bit.html">Bit</a> Bucket uses Boost as well as several C++11 features. VS2010 compiles <a class="el" href="class_bit.html">Bit</a> Bucket just fine, as well as VS2012, and the latest GCC and Clang.</p>
<p><b>Credits and licensing:</b></p>
<p><a class="el" href="class_bit.html">Bit</a> Bucket (c) 2012 was written by Assaf Muller. The code is under the MIT license, which means you can use it for closed, open source, free and commercial products. It is currently hosted at: <a href="https://github.com/assafmuller/Bit-Bucket">https://github.com/assafmuller/Bit-Bucket</a>. Feel free to fork and pull request! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 29 2012 14:07:43 for Bit Bucket by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
